import * as chai from 'chai';
import { expect } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { Container } from 'inversify';
import * as sinon from 'sinon';
import { SinonSandbox } from 'sinon';
import { constants } from '../../../src/helpers';
import { Symbols } from '../../../src/ioc/symbols';
import { SignedBlockType } from '../../../src/logic';
import { RoundsModule } from '../../../src/modules';
import sql from '../../../src/sql/logic/rounds';
import {
  AccountsModuleStub,
  AppStateStub,
  BusStub,
  DbStub,
  DelegatesModuleStub,
  LoggerStub,
  RoundLogicStub,
  RoundsLogicStub,
  SlotsStub,
  SocketIOStub
} from '../../stubs';

import { createFakeBlock } from '../../utils/blockCrafter';

chai.use(chaiAsPromised);

// tslint:disable no-unused-expression
describe('modules/rounds', () => {

  let instance: RoundsModule;
  let container: Container;
  let sandbox: SinonSandbox;
  let block: SignedBlockType;
  let delegatesModuleStub: DelegatesModuleStub;
  let accountsModuleStub: AccountsModuleStub;
  let loggerStub: LoggerStub;
  let slotsStub: SlotsStub;
  let dbStub: DbStub;
  let busStub: BusStub;
  let socketIOStub: SocketIOStub;
  let appStateStub: AppStateStub;
  let roundsLogicStub: RoundsLogicStub;
  let roundLogicStub: RoundLogicStub;

  before(() => {
    container = new Container();

    // Generic
    container.bind(Symbols.generic.db).to(DbStub).inSingletonScope();
    container.bind(Symbols.generic.socketIO).to(SocketIOStub).inSingletonScope();

    // Helpers
    container.bind(Symbols.helpers.logger).to(LoggerStub).inSingletonScope();
    container.bind(Symbols.helpers.slots).to(SlotsStub).inSingletonScope();
    container.bind(Symbols.helpers.constants).toConstantValue(constants);
    container.bind(Symbols.helpers.bus).to(BusStub).inSingletonScope();

    // Logic
    container.bind(Symbols.logic.appState).to(AppStateStub);
    container.bind(Symbols.logic.rounds).to(RoundsLogicStub);
    container.bind(Symbols.logic.round).to(RoundLogicStub);

    // Modules
    container.bind(Symbols.modules.delegates).to(DelegatesModuleStub);
    container.bind(Symbols.modules.accounts).to(AccountsModuleStub);
    container.bind(Symbols.modules.rounds).to(RoundsModule);
    block = createFakeBlock();
  });

  beforeEach(() => {
    sandbox             = sinon.sandbox.create();
    instance            = container.get(Symbols.modules.rounds);
    delegatesModuleStub = container.get(Symbols.modules.delegates);
    accountsModuleStub  = container.get(Symbols.modules.accounts);
    loggerStub          = container.get(Symbols.helpers.logger);
    slotsStub           = container.get(Symbols.helpers.slots);
    dbStub              = container.get(Symbols.generic.db);
    busStub             = container.get(Symbols.helpers.bus);
    socketIOStub        = container.get(Symbols.generic.socketIO);
    appStateStub        = container.get(Symbols.logic.appState);
    roundsLogicStub     = container.get(Symbols.logic.rounds);
    roundLogicStub      = container.get(Symbols.logic.round);
    // Reset all stubs
    [delegatesModuleStub, accountsModuleStub, loggerStub, slotsStub, dbStub, busStub, socketIOStub, appStateStub,
     roundsLogicStub, roundLogicStub].forEach((stub: any) => {
      if (typeof stub.reset !== 'undefined') {
        stub.reset();
      }
      if (typeof stub.stubReset !== 'undefined') {
        stub.stubReset();
      }
    });
  });

  afterEach(() => {
    sandbox.restore();
  });

  describe('onFinishRound',  () => {
    it('should call socketIO.emit');
  });

  describe('onBlockchainReady',  () => {
    it('should call appStateLogic.set');
  });

  describe('cleanup',  () => {
    it('should call appStateLogic.set');
    it('should resolve');
  });

  describe('flush',  () => {
    it('should call db.none');
    it('should call logger.error if db.none throws');
    it('should reject if db.none throws');
  });

  describe('backwardTick',  () => {
    it('should call innerTick');
    it('should return from innerTick');
    it('should call logger.debug (in innerTick task)');
    it('should instanciate a new RoundLogic (in innerTick task)');
    it('should call roundLogic.mergeBlockGenerator (in innerTick task)');
    it('should then call roundLogic.backwardLand if passed roundLogicScope.finishRound is true (in innerTick task)');
    it('should then call roundLogic.markBlockId (in innerTick task)');
  });

  describe('tick',  () => {
    it('should call innertick');
    it('should return from innerTick');
    describe('in callback generated by txGenerator', () => {
      it('should call logger.debug');
      it('should create a new RoundLogic');
      it('should call getSnapshotRounds once or twice');
      it('should call mergeBlockGenerator');
      it('should return from mergeBlockGenerator');
      describe('then, if this was the last block in round', () => {
        it('should call roundLogic.land');
        it('should then call bus.message');
        it('should then call roundLogic.truncateBlocks if snapshotRound is true');
      });
      describe(' else', () => {
        it('should return null');
      });
      it('should then call roundLogic.markBlockId');
    });
    describe('in afterTxPromise', () => {
      it('should not call anything if (block.height + 1) % this.slots.delegates !== 0');
      it('should logger.debug');
      it('should call db.tx');
      it('should call tx.batch');
      it('should call tx.none 4 times');
      it('should call logger.error if round tx fails');
      it('should reject if round tx fails');
      it('should call logger.trace');
    });
  });

  describe('getSnapshotRounds',  () => {
    it('should call appStateLogic.get and return it');
  });

  describe('innerTick',  () => {
    it('should call roundsLogic.calcRound twice');
    it('should call appStateLogic.set');
    it('should call sumRound if finishRound');
    it('should set roundFees: 0, roundRewards: [0], roundDelegates: [block.generatorPublicKey] if block.height = 1');
    it('should call getOutsiders if finishRound');
    it('should build roundLogicScope as expected');
    it('should call txGenerator');
    it('should call db.tx');
    it('should call afterTxPromise');
    it('should call appStateLogic.set');
    describe('anything trows in main try block',  () => {
      it('should call logger.warn');
      it('should call appStateLogic.set');
      it('should throw the catched error');
    });
  });

  describe('getOutsiders',  () => {
    it('should call roundsLogic.lastInRound');
    it('should remove roundDelegates');
    it('should call accountsModule.generateAddressByPublicKey for each of the outsiders');
    it('should return an array of addresses');
  });

  describe('sumRound',  () => {
    it('should call logger.debug');
    it('should call db.query');
    it('should call logger.error twice and reject if db.query rejects');
    it('should floor rewards');
    it('should floor fees');
    it('should return an object with rewards, fees and delegates');
  });

});
